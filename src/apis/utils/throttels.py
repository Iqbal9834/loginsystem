import functools

from rest_framework.response import Response
from rest_framework.throttling import (
    AnonRateThrottle,
    ScopedRateThrottle,
    SimpleRateThrottle,
    UserRateThrottle,
)

__all__ = [
    "UserRateThrottle",
    "AnonRateThrottle",
    "ScopedRateThrottle",
    "ResponseStatusCodeThrottle",
    "SimpleRateThrottle",
    "BurstAnonRateThrottle",
    "SustainedAnonRateThrottle",
]


class BurstAnonRateThrottle(AnonRateThrottle):
    scope = "anon_burst"


class SustainedAnonRateThrottle(AnonRateThrottle):
    scope = "anon_sustained"


class ResponseStatusCodeThrottle(SimpleRateThrottle):
    """
    Limits the rate of API calls that may be made by an anonymous or an
    authenticated user based on response status code. Any view that has
    `throttle_scope` property or has passed the value of `scope` as a kwarg
    while initializing this class will be throttled.
    The unique cache key will be generated by concatenating the user id or IP
    of the request, and the scope of the view being accessed.

    It can be used in two ways.
    1. Use it as decorator on view method
    ```python
    class MyView(ApiView):
      @ResponseStatusCodeThrottle(status_codes=[400],
      throttle_scope='scope_name')
      def post(request, *args, **kwargs):
        pass
    ```

    2. Add this class in `throttle_classes` attribute in view class and
    explicitly call `ResponseStatusCodeThrottle.throttle_status_code()`
    inside the view. Make sure that the value of `throttle_scope` and the value
    of `scope` used to initialize this class is same.
    ```python
    class MyView(ApiView):
      throttle_classes = [ResponseStatusCodeThrottle,]
      throttle_scope = ''
      def post(request, *args, **kwargs):
        throttle = ResponseStatusCodeThrottle(status_codes=[400])
        # do whatever you want to do
        # when you are returning response before that call
        throttle.throttle_status_code(request, self,
        status_code=response.status_code)
        pass
    ```
    """

    scope_attr = "throttle_scope"

    def __init__(self, status_codes=None, throttle_scope=None):
        # Override the usual SimpleRateThrottle, because we can't determine
        # the rate until called by the view.
        if status_codes is None:
            status_codes = []
        self.status_codes = status_codes
        self.scope = throttle_scope

    def __call__(self, view_method, *args, **kwargs):
        throttle = self

        @functools.wraps(view_method)
        def wrapper(view, request, *args, **kwargs):

            # do throttling check
            if not throttle.allow_request(request, view):
                duration = max([throttle.wait()], default=None)
                view.throttled(request, duration)

            response = view_method(view, request, *args, **kwargs)

            if isinstance(response, Response):
                throttle.throttle_status_code(
                    request, view, status_code=response.status_code
                )
            return response

        return wrapper

    def _throttle_success(self, request, view):

        if self._allow_request(view):
            return True
        self.key = self.get_cache_key(request, view)
        if self.key is None:
            return True

        self.history = self.cache.get(self.key, [])
        self.now = self.timer()
        # Drop any requests from the history which have now passed the
        # throttle duration
        while self.history and self.history[-1] <= self.now - self.duration:
            self.history.pop()

        self.history.insert(0, self.now)
        self.cache.set(self.key, self.history, self.duration)
        return True

    def throttle_success(self):
        # We override this, because we don't update history of attempts in
        # cache while doing allow request. This should be updated based on
        # response status code
        return True

    def _allow_request(self, view):
        """
        As we have override `__init__` method where the values of `rate`,
         `num_request` and `duration` were seT, this method now
         initialize those values.
        :param view:
        :return:
        """
        # Value of `scope` as a kwarg in `__init__` method is prioritize
        # before the one set as `throttle_scope` set in view.
        self.scope = getattr(self, "scope", None) or getattr(
            view, self.scope_attr, None
        )
        if not self.scope:
            return True
        # Determine the allowed request rate as we normally would during
        # the `__init__` call.
        self.rate = self.get_rate()
        self.num_requests, self.duration = self.parse_rate(self.rate)
        return False

    def allow_request(self, request, view):

        # calling `_allow_request` method first which  initializes the values
        # of `rate`, `num_request` and `duration`.
        if self._allow_request(view):
            return True
        return super().allow_request(request, view)

    def throttle_status_code(self, request, view, status_code=None):
        """
        User should call this method before sending response in view,
        otherwise this throttle will not work
        :param request:
        :param view:
        :param status_code:
        :return:
        """
        if status_code in self.status_codes:
            self._throttle_success(request, view)

    def get_cache_key(self, request, view):
        """
        If `view.throttle_scope` is not set, don't apply this throttle.

        Otherwise generate the unique cache key by concatenating the user id
        with the '.throttle_scope` property of the view.
        """
        if request.user.is_authenticated:
            ident = request.user.pk
        else:
            ident = self.get_ident(request)

        return self.cache_format % {"scope": self.scope, "ident": ident}
